package Main;

import DataStructures.TuringMachine;
import Parsers.TuringMachineFileParser;

import java.io.FileNotFoundException;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Prints data by repeatedly measuring times taken for different Turing machines to complete
 * with varying size data.
 */
public class DataMeasures {

    /**
     * Parser for the Turing machine input files.
     */
    private TuringMachineFileParser parser;

    public DataMeasures() {
        this.parser = new TuringMachineFileParser();
    }

    /**
     * Print number of transition data generated by the palindrome Turing machine under varying string lengths.
     */
    public void printPalindromeData() {

        // file path to machine description
        String machineLocation = "TestFiles/Palindrome/machine_input.txt";

        // Turing machine that will be used
        TuringMachine tm = null;

        // the mean number of transitions made for a certain string length - calculated as mean
        // from number of repeat samples
        long meanNumberOfTransitionsMade;

        // number of repeat samples done
        final int NUMBER_OF_REPEAT_SAMPLES = 10;

        // collection of values we collect for every string length
        long vals[]= new long[NUMBER_OF_REPEAT_SAMPLES];

        // try to create the Turing machine from the file at the given machine location
        try {
            tm = this.parser.parseFile(machineLocation);
        } catch (FileNotFoundException e) {
            System.err.println("Palindrome machine description file not found.");
            System.exit(1);
        }

        // the string that will be tested at every iteration
        String testString;

        for(int i = 1; i < 50; i++) {

            for(int j = 0; j < 10; j++) {

                // generate a random half of a palindrome and append its reverse on the
                // end of it to use as test data
                testString = this.getRandomABCCombination(i);
                testString += new StringBuilder(testString).reverse().toString();

                //run the Turing machine so we can take the number of transitions it used
                tm.checkIfStringIsAccepted(testString);

                //add the number of transitions used to the collection of number transitions
                // to take the mean from
                vals[j] = tm.getNumberOfTransitionsMade();
            }

            // take the average and output it with the length of string
            meanNumberOfTransitionsMade = this.takeMean(vals);

            System.out.println("(" + i * 2 + "," + meanNumberOfTransitionsMade + ") ");
        }


    }

    /**
     * Print number of transition data generated by the binary addition Turing machine under varying length inputs.
     */
    public void printBinaryAdditionData() {

        // file path to machine description
        String machineLocation = "TestFiles/BinaryAddition/machine_input.txt";

        // Turing machine that will be used
        TuringMachine tm = null;

        // the mean number of transitions made for a certain input length - calculated as mean
        // from number of repeat samples
        long meanNumberOfTransitionsMade;

        // number of repeat samples done
        final int NUMBER_OF_REPEAT_SAMPLES = 10;

        // collection of values we collect for every string length
        long vals[]= new long[NUMBER_OF_REPEAT_SAMPLES];

        // try to create the Turing machine from the file at the given machine location
        try {
            tm = this.parser.parseFile(machineLocation);
        } catch (FileNotFoundException e) {
            System.err.println("Binary addition machine description file not found.");
            System.exit(1);
        }

        // the string that will be tested at every iteration
        String testString = "";

        for(int i = 1; i < 30; i++) {

            for(int j = 0; j < 10; j++) {

                // get a test addition sum to use
                testString = this.generateBinaryAdditionString(i);

                //run the Turing machine so we can take the number of transitions it used
                tm.checkIfStringIsAccepted(testString);

                //add the number of transitions used to the collection of number transitions
                // to take the mean from
                vals[j] = tm.getNumberOfTransitionsMade();
            }

            // take the average and output it with the length of string
            meanNumberOfTransitionsMade = this.takeMean(vals);

            System.out.println("(" + testString.length() + "," + meanNumberOfTransitionsMade + ") ");
        }

    }

    /**
     * Print number of transition data generated by the sort Turing machine under varying length inputs.
     */
    public void printSortData() {

        // file path to machine description
        String machineLocation = "TestFiles/Sort/machine_input.txt";

        // Turing machine that will be used
        TuringMachine tm = null;

        // the mean number of transitions made for a certain input length - calculated as mean
        // from number of repeat samples
        long meanNumberOfTransitionsMade;

        // number of repeat samples done
        final int NUMBER_OF_REPEAT_SAMPLES = 10;

        // collection of values we collect for every string length
        long vals[]= new long[NUMBER_OF_REPEAT_SAMPLES];

        // try to create the Turing machine from the file at the given machine location
        try {
            tm = this.parser.parseFile(machineLocation);
        } catch (FileNotFoundException e) {
            System.err.println("Sort machine description file not found.");
            System.exit(1);
        }

        // the string that will be tested at every iteration
        String testString = "";

        for(int i = 1; i < 100; i++) {

            for(int j = 0; j < 10; j++) {

                // get a random ABC string to use for test data
                testString = this.getRandomABCCombination(i);

                //run the Turing machine so we can take the number of transitions it used
                tm.checkIfStringIsAccepted(testString);

                //add the number of transitions used to the collection of number transitions
                // to take the mean from
                vals[j] = tm.getNumberOfTransitionsMade();
            }

            // take the average and output it with the length of string
            meanNumberOfTransitionsMade = this.takeMean(vals);

            System.out.println("(" + testString.length() + "," + meanNumberOfTransitionsMade + ") ");
        }
    }

    /**
     * Print number of transition data generated by the reverse string Turing machine under varying length inputs.
     */
    public void printReverseStringData() {

        // file path to machine description
        String machineLocation = "TestFiles/ReverseString/machine_input.txt";

        // Turing machine that will be used
        TuringMachine tm = null;

        // the mean number of transitions made for a certain input length - calculated as mean
        // from number of repeat samples
        long meanNumberOfTransitionsMade;

        // number of repeat samples done
        final int NUMBER_OF_REPEAT_SAMPLES = 10;

        // collection of values we collect for every string length
        long vals[]= new long[NUMBER_OF_REPEAT_SAMPLES];

        // try to create the Turing machine from the file at the given machine location
        try {
            tm = this.parser.parseFile(machineLocation);
        } catch (FileNotFoundException e) {
            System.err.println("Sort machine description file not found.");
            System.exit(1);
        }

        // the string that will be tested at every iteration
        String testString = "";

        for(int i = 1; i < 100; i++) {

            for(int j = 0; j < 10; j++) {

                // get a random combination to be reversed
                testString = this.getRandomABCCombination(i) + '#';

                //run the Turing machine so we can take the number of transitions it used
                tm.checkIfStringIsAccepted(testString);

                //add the number of transitions used to the collection of number transitions
                // to take the mean from
                vals[j] = tm.getNumberOfTransitionsMade();
            }

            // take the average and output it with the length of string
            meanNumberOfTransitionsMade = this.takeMean(vals);

            System.out.println("(" + testString.length() + "," + meanNumberOfTransitionsMade + ") ");
        }

    }

    /**
     * Prints the square values from 1-100 so that they can be compared against the gradient
     * of the other graphs.
     */
    public void printSquareData() {
        for(int i = 1; i < 100; i++) {
            System.out.println("(" + i + "," + (int) Math.pow(i, 2) + ") ");
        }
    }

    /**
     * Generates random string of repeated {a,b,c} of the given length.
     * @param length Length of string to generate.
     * @return String of the given length of a random combination of {a,b,c}
     */
    private String getRandomABCCombination(int length) {
        String result = "";
        final int max = (int) 'c', min = (int) 'a';
        for(int i = 0; i < length; i++) {
            int randomNum = ThreadLocalRandom.current().nextInt(min, max + 1);
            result += (char) randomNum;
        }

        return result;
    }

    /**
     * Generate a binary addition to use, made by adding numbers together
     * within the same power of two range specified by length.
     * @param length The length of the binary string to use.
     * @return A valid binary addition string to use in the Turing machine.
     */
    public String generateBinaryAdditionString(int length) {

        /*The three numbers to use in the binary addition combination.*/
        long firstNum = ThreadLocalRandom.current().nextLong( (long) Math.pow(2, length), (long) Math.pow(2, length + 1)),
                secondNum = ThreadLocalRandom.current().nextLong( (long) Math.pow(2, length), (long) Math.pow(2, length + 1)),
                result = firstNum + secondNum;

        /* Return the numbers reversed and put together with the hash symbol. */
        return (new StringBuilder(Long.toBinaryString(firstNum)).reverse().toString()) + "#"
                + (new StringBuilder(Long.toBinaryString(secondNum)).reverse().toString()) + "#"
                + (new StringBuilder(Long.toBinaryString(result)).reverse().toString());
    }

    private long takeMean(long[] vals) {
        long result = 0;
        for(long i : vals) {
            result += i;
        }
        return  result / vals.length;
    }
}
