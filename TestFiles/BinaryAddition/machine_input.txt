#Binary Addition
states

#start state - filters out # symbol
q0

# recurring state
q1

q2
q3

q4
q5
q6
q7
q8
q9
q10
q11
qa +
qr -

alphabet 6 0 1 # | x c

#initial state
q0 0 q2 | R
q0 1 q3 | R
q0 c qr c R
q0 # qr # R
q0 | qr | R
q0 x qr | R

#usual return state at beginning of machine
q1 0 q2 | R
q1 1 q3 | R
q1 c qr c R
q1 # q2 # R
q1 | q1 | R
q1 x qa x R

# state we go to after we see a 0
# wait for #
q2 0 q2 0 R
q2 1 q2 1 R
q2 c qr c R
q2 # q4 # R
q2 | qr | R
q2 x qr x R

# state we go to after we see a 1
# wait for #
q3 0 q3 0 R
q3 1 q3 1 R
q3 c qr c R
q3 # q5 # R
q3 | qr | R
q3 x qr x R

# go to this state after we see a 0 and a hash - need to go through used numbers i.e x's
q4 0 q6 x R
q4 1 q7 x R
q4 c q8 x R
q4 # q6 # R
q4 | qr | R
q4 x q4 x R

# go to this state after we see a 1 and a hash - need to go through used numbers i.e x's
q5 0 q7 x R
q5 1 q6 c R
q5 c q10 x R
q5 # q7 # R
q5 | qr | R
q5 x q5 x R

# q6 : result number should be 0 - wait for next number
# i.e 0 + 0
# or 1 + 1
# or 0 + c + 1
# or 1 + c + 0

q6 0 q6 0 R
q6 1 q6 1 R
q6 c qr c R
q6 # q10 # R
q6 | qr | R
q6 x qr x R

# q7 : result number should be 1 - wait for next number
# i.e 0 + 1
# or 1 + 0
# or 0 + c + 0
# or 1 + c + 1

q7 0 q7 0 R
q7 1 q7 1 R
q7 c qr c R
q7 # q11 # R
q7 | qr | R
q7 x qr x R

# q8 : 0 + c decision
q8 0 q7 x R
q8 1 q6 c R
q8 c qr c R
q8 # qr # R
q8 | qr | R
q8 x qr x R

# q9 : 1 + c decision
q9 0 q6 c R
q9 1 q7 c R
q9 c qr c R
q9 # qr # R
q9 | qr | R
q9 x qr x R
